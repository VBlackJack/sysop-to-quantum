{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Guide Ops : Transition vers le Quantique","text":"<p>Bienvenue dans ce r\u00e9f\u00e9rentiel technique d\u00e9di\u00e9 aux \u00e9quipes Infrastructure et Op\u00e9rations.</p>"},{"location":"#pourquoi-ce-guide","title":"Pourquoi ce guide ?","text":"<p>En tant que SysOp ou Architecte Cloud, l'informatique quantique peut sembler \u00eatre un sujet lointain, r\u00e9serv\u00e9 aux chercheurs en physique. Cependant, l'impact sur nos infrastructures est imminent, notamment sur la s\u00e9curit\u00e9 des flux et la mani\u00e8re dont nous consommons les ressources de calcul.</p> <p>Ce guide a \u00e9t\u00e9 con\u00e7u pour anticiper l'obsolescence de nos standards actuels et pr\u00e9parer la s\u00e9curisation des infrastructures d\u00e8s aujourd'hui, sans n\u00e9cessiter de bagage math\u00e9matique complexe.</p>"},{"location":"#contenu-du-guide","title":"Contenu du Guide","text":"<p>Le r\u00e9f\u00e9rentiel est divis\u00e9 en trois piliers fondamentaux :</p> <ol> <li>Glossaire SysAdmin : Comprendre les concepts (Qubit, Intrication, D\u00e9coh\u00e9rence) par l'analogie avec le hardware et le r\u00e9seau classique.</li> <li>Infra Hybride (Terraform) : Apprendre \u00e0 provisionner des environnements de calcul quantique via le code (IaC) sur les fournisseurs Cloud (AWS Braket).</li> <li>S\u00e9curit\u00e9 Post-Quantique : Identifier la menace \"Harvest Now, Decrypt Later\" et durcir vos configurations (SSH, Ansible) avec les nouveaux standards du NIST.</li> </ol> <p>!!! info \"Work in Progress\"     Ce projet est en cours de r\u00e9daction. Les exemples de code et les scripts de d\u00e9ploiement sont test\u00e9s sur des simulateurs quantiques et des instances de d\u00e9veloppement.</p> <p>Projet maintenu par Julien Bombled Licence Apache 2.0</p>"},{"location":"glossaire/","title":"1. Glossaire SysAdmin","text":""},{"location":"glossaire/#glossaire-quantique-pour-linfrastructure","title":"Glossaire Quantique pour l'Infrastructure","text":"<p>Ce glossaire d\u00e9finit les concepts fondamentaux du calcul quantique \u00e0 travers le prisme de l'administration syst\u00e8me et de l'architecture cloud.</p>"},{"location":"glossaire/#qubit","title":"Qubit","text":"<p>Th\u00e9orie : L'unit\u00e9 de base de l'information quantique. Contrairement au bit classique (0 ou 1), il peut exister dans une superposition d'\u00e9tats.</p> <p>Vision SysAdmin : Consid\u00e9rez le qubit comme une cellule de RAM extr\u00eamement volatile et d\u00e9pourvue de correction d'erreurs (ECC). Alors qu'un bit est un interrupteur stable, le qubit est une toupie en rotation : il contient une information complexe tant qu'il tourne, mais devient une simple valeur binaire d\u00e8s qu'on tente de le \"lire\" (mesure). Sa gestion n\u00e9cessite un environnement physique ultra-contr\u00f4l\u00e9, bien au-del\u00e0 de n'importe quel datacenter Tier IV.</p>"},{"location":"glossaire/#superposition","title":"Superposition","text":"<p>Th\u00e9orie : Propri\u00e9t\u00e9 permettant \u00e0 un qubit d'\u00eatre dans plusieurs \u00e9tats simultan\u00e9ment jusqu'\u00e0 ce qu'il soit mesur\u00e9.</p> <p>Vision SysAdmin : C'est une forme de \"parall\u00e9lisme natif\". Imaginez lancer un script de recherche sur une base de donn\u00e9es : l\u00e0 o\u00f9 un CPU classique it\u00e8re sur chaque entr\u00e9e (ou utilise plusieurs threads), un processeur quantique \"voit\" toutes les solutions possibles en un seul cycle d'horloge. C'est comme si votre application pouvait explorer toutes les branches d'un <code>if/else</code> simultan\u00e9ment sans avoir \u00e0 instancier plusieurs processus.</p>"},{"location":"glossaire/#intrication-entanglement","title":"Intrication (Entanglement)","text":"<p>Th\u00e9orie : Ph\u00e9nom\u00e8ne o\u00f9 deux qubits deviennent li\u00e9s de telle sorte que l'\u00e9tat de l'un d\u00e9pend instantan\u00e9ment de l'\u00e9tat de l'autre, quelle que soit la distance.</p> <p>Vision SysAdmin : L'analogie la plus proche est celle d'un RAID 1 (Mirroring) instantan\u00e9 et sans aucune latence r\u00e9seau. Si vous modifiez une donn\u00e9e sur le \"disque A\", le \"disque B\" refl\u00e8te ce changement imm\u00e9diatement, m\u00eame s'il se trouve dans une r\u00e9gion Cloud diff\u00e9rente. C'est une synchronisation d'\u00e9tat qui ne passe par aucun c\u00e2ble, d\u00e9fiant les limites habituelles de la bande passante et de la propagation du signal.</p>"},{"location":"glossaire/#decoherence","title":"D\u00e9coh\u00e9rence","text":"<p>Th\u00e9orie : Perte de l'\u00e9tat quantique d'un qubit due aux interactions avec son environnement (chaleur, vibrations, ondes).</p> <p>Vision SysAdmin : C'est le \"bruit\" ultime ou la corruption de donn\u00e9es massive. En tant qu'Ops, nous luttons contre le bit-rot ou les pannes mat\u00e9rielles ; ici, la donn\u00e9e a un Time-to-Live (TTL) ultra-court. La d\u00e9coh\u00e9rence, c'est ce qui arrive quand votre \"syst\u00e8me\" s'effondre parce qu'un technicien a ouvert la porte de la salle serveur ou qu'un ventilateur a vibr\u00e9 trop fort. C'est l'ennemi num\u00e9ro 1 de la haute disponibilit\u00e9 quantique.</p>"},{"location":"glossaire/#qpu-quantum-processing-unit","title":"QPU (Quantum Processing Unit)","text":"<p>Th\u00e9orie : Le processeur physique qui manipule les qubits pour effectuer des calculs.</p> <p>Vision SysAdmin : Ne voyez pas le QPU comme un rempla\u00e7ant du CPU, mais comme un acc\u00e9l\u00e9rateur sp\u00e9cialis\u00e9, \u00e0 l'image d'un GPU pour le rendu ou d'un FPGA pour le r\u00e9seau. Dans une architecture hybride, votre code s'ex\u00e9cute sur un serveur classique (Python/C++), et d\u00e9l\u00e8gue des t\u00e2ches sp\u00e9cifiques (optimisation, simulation chimique) au QPU via une API Cloud (Azure Quantum, AWS Braket). C'est une ressource externe manag\u00e9e.</p>"},{"location":"glossaire/#nisq-noisy-intermediate-scale-quantum","title":"NISQ (Noisy Intermediate-Scale Quantum)","text":"<p>Th\u00e9orie : L'\u00e8re actuelle de l'informatique quantique, caract\u00e9ris\u00e9e par des processeurs de taille moyenne et tr\u00e8s sensibles aux erreurs.</p> <p>Vision SysAdmin : C'est l'\u00e9quivalent d'un hardware en version Alpha instable. Imaginez administrer un cluster de serveurs qui produisent des erreurs de calcul al\u00e9atoires toutes les 100 millisecondes. En tant qu'ing\u00e9nieurs, notre r\u00f4le dans l'\u00e8re NISQ est de mettre en place des \"m\u00e9canismes de retry\" et des algorithmes de correction logicielle pour compenser le manque de fiabilit\u00e9 du mat\u00e9riel. On fait de la r\u00e9silience applicative au-dessus d'une infrastructure qui n'est pas encore \"Fault Tolerant\".</p>"},{"location":"securite/","title":"3. S\u00e9curit\u00e9 Post-Quantique","text":""},{"location":"securite/#securite-post-quantique-pqc","title":"S\u00e9curit\u00e9 Post-Quantique (PQC)","text":""},{"location":"securite/#la-menace-harvest-now-decrypt-later","title":"La Menace : \"Harvest Now, Decrypt Later\"","text":"<p>Pourquoi un SysAdmin devrait-il se soucier du quantique aujourd'hui, alors que les ordinateurs capables de casser le chiffrement RSA n'existeront peut-\u00eatre pas avant 10 ou 15 ans ?</p> <p>La r\u00e9ponse tient en une phrase : R\u00e9colter maintenant, d\u00e9chiffrer plus tard.</p> <p>Les acteurs malveillants (ou \u00e9tatiques) interceptent et stockent d\u00e8s aujourd'hui des t\u00e9raoctets de trafic chiffr\u00e9 (VPN, HTTPS, SSH). Ces donn\u00e9es sont illisibles pour l'instant. Mais si ces donn\u00e9es ont une dur\u00e9e de vie longue (secrets industriels, donn\u00e9es m\u00e9dicales, dossiers d\u00e9fense), elles seront expos\u00e9es d\u00e8s qu'un ordinateur quantique suffisamment puissant (\"Cryptographically Relevant Quantum Computer\" - CRQC) sera disponible.</p> <p>La migration vers la cryptographie post-quantique n'est pas un projet pour 2035, c'est une urgence pour prot\u00e9ger les flux actuels.</p>"},{"location":"securite/#les-nouveaux-standards-nist","title":"Les Nouveaux Standards (NIST)","text":"<p>En 2024, le NIST a officialis\u00e9 les algorithmes con\u00e7us pour r\u00e9sister aux attaques quantiques. Pour l'Ops, ce sont simplement de \"nouveaux noms\" \u00e0 ajouter dans les fichiers de configuration SSL/TLS et SSH.</p> <ul> <li> <p>ML-KEM (anciennement Kyber) :</p> <ul> <li>Usage : \u00c9change de cl\u00e9s (Key Encapsulation Mechanism). C'est ce qui remplace RSA et Elliptic Curve (ECDH) lors de l'\u00e9tablissement d'une connexion s\u00e9curis\u00e9e (Handshake).</li> <li>Caract\u00e9ristique : Tr\u00e8s rapide, mais cl\u00e9s l\u00e9g\u00e8rement plus grosses.</li> </ul> </li> <li> <p>ML-DSA (anciennement Dilithium) :</p> <ul> <li>Usage : Signatures num\u00e9riques. Utilis\u00e9 pour signer des certificats, des documents ou authentifier des serveurs.</li> <li>Caract\u00e9ristique : Remplace RSA/ECDSA pour l'identit\u00e9.</li> </ul> </li> </ul>"},{"location":"securite/#mise-en-pratique-hardening-ssh-avec-ansible","title":"Mise en Pratique : Hardening SSH avec Ansible","text":"<p>En attendant le support natif et g\u00e9n\u00e9ralis\u00e9 des algorithmes PQC (Post-Quantum Cryptography) dans toutes les distros, la premi\u00e8re \u00e9tape est l'hygi\u00e8ne cryptographique : supprimer les algos faibles qui seront les premiers \u00e0 tomber.</p> <p>Voici un playbook Ansible pour durcir un parc de serveurs Linux.</p> <pre><code># ssh_hardening.yml\n# Author: Julien Bombled\n# License: Apache 2.0\n---\n- name: Hardening SSH for Post-Quantum Preparation\n  hosts: all\n  become: true\n  tasks:\n\n    - name: Check OpenSSL version\n      command: openssl version\n      register: openssl_ver\n      changed_when: false\n\n    - name: Display OpenSSL Version\n      debug:\n        msg: \"Current OpenSSL Version: {{ openssl_ver.stdout }}. Look for 3.x+ for future PQC support.\"\n\n    - name: Ensure weak ciphers are disabled in sshd_config\n      lineinfile:\n        path: /etc/ssh/sshd_config\n        regexp: \"^Ciphers\"\n        # We enforce ChaCha20 and AES-GCM. We explicitly drop CBC and weaker modes.\n        line: \"Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com\"\n        state: present\n        validate: 'sshd -t -f %s'\n      notify: Restart SSH\n\n    - name: Ensure weak Key Exchange Algorithms (KEX) are disabled\n      lineinfile:\n        path: /etc/ssh/sshd_config\n        regexp: \"^KexAlgorithms\"\n        # We prioritize Curve25519. In the future, this is where 'sntrup761x25519-sha512' (Hybrid) will be added.\n        # Dropping Diffie-Hellman-Group1-SHA1 and other legacy KEX.\n        line: \"KexAlgorithms curve25519-sha256,curve25519-sha256@libssh.org,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512\"\n        state: present\n        validate: 'sshd -t -f %s'\n      notify: Restart SSH\n\n    - name: Disable DSA and RSA host keys (Prefer ED25519)\n      lineinfile:\n        path: /etc/ssh/sshd_config\n        regexp: \"^HostKey {{ item }}\"\n        state: absent\n      loop:\n        - /etc/ssh/ssh_host_dsa_key\n        - /etc/ssh/ssh_host_rsa_key\n      notify: Restart SSH\n\n  handlers:\n    - name: Restart SSH\n      service:\n        name: sshd\n        state: restarted\n</code></pre>"},{"location":"securite/#note-sur-les-algorithmes-hybrides","title":"Note sur les algorithmes hybrides","text":"<p>Dans un futur proche (d\u00e9j\u00e0 dispo sur OpenSSH r\u00e9cents), vous verrez appara\u00eetre des KEX hybrides comme <code>sntrup761x25519-sha512</code>. L'id\u00e9e est de combiner un algo classique robuste (X25519) avec un algo quantique. Si l'algo quantique est cass\u00e9, la protection classique reste. C'est la strat\u00e9gie de s\u00e9curit\u00e9 recommand\u00e9e pour la transition.</p>"},{"location":"securite/#limpact-sur-la-performance-note-sysop","title":"L'impact sur la Performance (Note SysOp)","text":"<p>La migration vers le Post-Quantique a un co\u00fbt physique que l'Ops doit anticiper :</p> <ol> <li>Taille des paquets : Les cl\u00e9s et signatures PQC sont beaucoup plus lourdes que celles de RSA/ECC.<ul> <li>RSA-2048 : Cl\u00e9 publique ~256 octets.</li> <li>ML-KEM (Kyber) : Cl\u00e9 publique ~800 \u00e0 1500 octets.</li> <li>ML-DSA (Dilithium) : Signature ~2400 octets.</li> </ul> </li> <li>Impact R\u00e9seau : Ces tailles peuvent causer la fragmentation des paquets IP (d\u00e9passement du MTU de 1500 bytes). Cela peut augmenter la latence lors des handshakes TLS, surtout sur les r\u00e9seaux mobiles ou instables.</li> <li>Charge Load-Balancers : Vos terminaux SSL/TLS (Nginx, HAProxy, F5) devront g\u00e9rer des buffers plus gros et consommeront un peu plus de RAM par connexion concurrente.</li> </ol> <p>Pr\u00e9parez vos capacit\u00e9s de bande passante et surveillez le \"Time To First Byte\" (TTFB) lors de la migration.</p>"},{"location":"infra/architecture/","title":"Architecture Ref","text":""},{"location":"infra/architecture/#architecture-hybride-de-reference","title":"Architecture Hybride de R\u00e9f\u00e9rence","text":"<p>Cette page d\u00e9taille les interactions techniques entre le monde classique et le monde quantique. Le point cl\u00e9 \u00e0 retenir est l'asynchronisme : on ne \"parle\" pas \u00e0 un QPU en temps r\u00e9el, on lui soumet des jobs via une file d'attente.</p>"},{"location":"infra/architecture/#1-le-flux-de-donnees-workflow-asynchrone","title":"1. Le Flux de Donn\u00e9es (Workflow Asynchrone)","text":"<p>Dans ce sc\u00e9nario, une application financi\u00e8re demande une optimisation de portefeuille. Le calcul quantique \u00e9tant une ressource rare et lente (file d'attente mondiale), l'architecture doit \u00eatre Event-Driven.</p> <pre><code>sequenceDiagram\n    autonumber\n    participant User as Utilisateur\n    participant Web as WebServer (Classique)\n    participant Queue as JobQueue (Redis/SQS)\n    participant Worker as QuantumWorker\n    participant QPU as QPU (AWS Braket / IBM)\n    participant DB as Database\n\n    Note over User, Web: Monde Classique (Rapide)\n    User-&gt;&gt;Web: POST /optimize_portfolio {data}\n    Web-&gt;&gt;Queue: Push Job {id, params}\n    Web--&gt;&gt;User: 202 Accepted (Check status later)\n\n    Note over Queue, Worker: Traitement Asynchrone\n    Worker-&gt;&gt;Queue: Poll Job\n    Worker-&gt;&gt;Worker: Transpile Circuit (Prepare for QPU)\n\n    Note over Worker, QPU: Monde Quantique (Latence \u00c9lev\u00e9e)\n    Worker-&gt;&gt;QPU: Submit Quantum Task\n    QPU--&gt;&gt;Worker: Task ID\n    loop Polling Status\n        Worker-&gt;&gt;QPU: Get Status\n        QPU--&gt;&gt;Worker: \"QUEUED\" ... \"RUNNING\" ... \"COMPLETED\"\n    end\n    QPU-&gt;&gt;Worker: Return Measurement Results (Bitstrings)\n\n    Worker-&gt;&gt;DB: Save Optimization Result\n\n    User-&gt;&gt;Web: GET /jobs/{id}\n    Web-&gt;&gt;DB: Fetch Result\n    DB--&gt;&gt;Web: Result Found\n    Web--&gt;&gt;User: 200 OK {optimized_portfolio}\n</code></pre>"},{"location":"infra/architecture/#2-la-zone-rouge-segregation-et-securite","title":"2. La \"Zone Rouge\" : S\u00e9gr\u00e9gation et S\u00e9curit\u00e9","text":"<p>Pour les environnements sensibles (Banque, D\u00e9fense, OIV), il est imp\u00e9ratif de ne jamais exposer les donn\u00e9es brutes au Cloud Public qui h\u00e9berge le QPU.</p> <p>L'architecture repose sur un Proxy d'Obfuscation. Ce composant transforme les donn\u00e9es sensibles en param\u00e8tres math\u00e9matiques abstraits avant qu'elles ne quittent le r\u00e9seau priv\u00e9. Le QPU re\u00e7oit une \u00e9quation \u00e0 r\u00e9soudre, sans conna\u00eetre le contexte m\u00e9tier (noms des clients, montants r\u00e9els).</p> <pre><code>graph TD\n    subgraph \"Zone de Confiance (Priv\u00e9 / SecNumCloud)\"\n        style \"Zone de Confiance (Priv\u00e9 / SecNumCloud)\" fill:#e1f5fe,stroke:#01579b\n        App[Application M\u00e9tier]\n        SensData[(Donn\u00e9es Sensibles)]\n        App --&gt; SensData\n\n        Proxy[Obfuscation Proxy / Gateway]\n        style Proxy fill:#ffcc80,stroke:#e65100,stroke-width:2px\n\n        App -- \"Donn\u00e9es Brutes\" --&gt; Proxy\n        Proxy -- \"Anonymisation / Abstraction\" --&gt; Proxy\n    end\n\n    boundary[Firewall / DMZ]\n\n    subgraph \"Public Quantum Cloud\"\n        style \"Public Quantum Cloud\" fill:#f3e5f5,stroke:#4a148c\n        API[Cloud API Endpoint]\n        QPU_H[Quantum Hardware]\n\n        API --&gt; QPU_H\n    end\n\n    Proxy -- \"Circuit Abstrait (QASM)\" --&gt; boundary\n    boundary -- \"HTTPS (TLS 1.3 + PQC)\" --&gt; API\n\n    linkStyle 4 stroke:#f44336,stroke-width:2px,dasharray: 5 5;\n</code></pre>"},{"location":"infra/terraform/","title":"Terraform","text":""},{"location":"infra/terraform/#infrastructure-as-code-pour-le-quantique","title":"Infrastructure as Code pour le Quantique","text":""},{"location":"infra/terraform/#introduction-le-qpu-as-a-service","title":"Introduction : Le QPU \"As a Service\"","text":"<p>Pour un SysOp ou un Architecte Infrastructure, la premi\u00e8re chose \u00e0 comprendre est que le QPU (Quantum Processing Unit) n'est pas un mat\u00e9riel que vous allez installer dans vos baies serveurs (pour l'instant). Les contraintes de refroidissement (proche du z\u00e9ro absolu) et d'isolation magn\u00e9tique rendent l'h\u00e9bergement \"On-Premise\" impossible pour la majorit\u00e9 des entreprises.</p> <p>L'informatique quantique se consomme aujourd'hui exclusivement en mod\u00e8le PaaS/SaaS.</p> <p>Dans ce contexte, Terraform ne sert pas \u00e0 provisionner le processeur quantique lui-m\u00eame, mais \u00e0 construire l'environnement p\u00e9riph\u00e9rique (l'Hybrid Cloud) : 1.  Le stockage : O\u00f9 atterrissent les r\u00e9sultats des mesures (souvent volumineux). 2.  L'environnement de d\u00e9veloppement : Notebooks Jupyter manag\u00e9s pour soumettre les jobs. 3.  La s\u00e9curit\u00e9 (IAM) : Qui a le droit de d\u00e9penser du budget sur un QPU \u00e0 5000$/heure.</p>"},{"location":"infra/terraform/#architecture-hybride","title":"Architecture Hybride","text":"<p>Le sch\u00e9ma ci-dessous illustre le flux de provisionning et d'ex\u00e9cution. Terraform configure le \"Control Plane\" Cloud, qui fait le pont vers le hardware quantique.</p> <pre><code>graph LR\n    Dev[DevOps / Researcher] --&gt;|1. git push / apply| TF[Terraform]\n    TF --&gt;|2. Provision Resources| Cloud[Public Cloud Provider\\n(AWS / Azure / GCP)]\n\n    subgraph \"Managed Environment\"\n        NB[Managed Notebook\\n(Jupyter)]\n        Store[Object Storage\\n(S3 / Blob)]\n        IAM[IAM Policies]\n    end\n\n    Cloud --&gt; NB\n    Cloud --&gt; Store\n    Cloud --&gt; IAM\n\n    NB -.-&gt;|3. Submit Job via API| QService[Quantum Service\\n(Braket / Quantum)]\n    QService ===|4. Execution| QPU[QPU Hardware\\n(IonQ / Rigetti / IBM)]\n</code></pre>"},{"location":"infra/terraform/#exemple-concret-environnement-aws-braket","title":"Exemple Concret : Environnement AWS Braket","text":"<p>Voici un exemple de code Terraform (HCL) pour d\u00e9ployer un environnement de travail complet sur AWS utilisant le service Amazon Braket.</p> <p>Ce code d\u00e9ploie : *   Un Bucket S3 pour les inputs/outputs. *   Un Notebook SageMaker pr\u00e9-configur\u00e9 pour Braket (l'IDE du d\u00e9veloppeur quantique). *   Les R\u00f4les IAM n\u00e9cessaires.</p> <pre><code># main.tf\n# Author: Julien Bombled\n# License: Apache 2.0\n\nprovider \"aws\" {\n  region = \"us-east-1\" # Many quantum devices are region-specific\n}\n\n# 1. Storage for Quantum Job Results\n# The QPU will write measurement results directly here\nresource \"aws_s3_bucket\" \"quantum_results\" {\n  bucket = \"company-quantum-results-prod-001\"\n\n  tags = {\n    Environment = \"Production\"\n    Project     = \"Quantum-Hybrid\"\n  }\n}\n\n# 2. IAM Role for the Notebook\n# This role allows the Notebook to talk to Braket and S3\nresource \"aws_iam_role\" \"quantum_notebook_role\" {\n  name = \"QuantumNotebookRole\"\n\n  assume_role_policy = jsonencode({\n    Version = \"2012-10-17\"\n    Statement = [{\n      Action = \"sts:AssumeRole\"\n      Effect = \"Allow\"\n      Principal = {\n        Service = \"sagemaker.amazonaws.com\"\n      }\n    }]\n  })\n}\n\n# Attach standard Braket permissions\nresource \"aws_iam_role_policy_attachment\" \"braket_full_access\" {\n  role       = aws_iam_role.quantum_notebook_role.name\n  policy_arn = \"arn:aws:iam::aws:policy/AmazonBraketFullAccess\"\n}\n\n# 3. The Development Environment (Managed Notebook)\n# This is where the Python SDK (Braket) runs\nresource \"aws_sagemaker_notebook_instance\" \"quantum_dev_env\" {\n  name          = \"Quantum-Dev-Instance-XL\"\n  role_arn      = aws_iam_role.quantum_notebook_role.arn\n  instance_type = \"ml.t3.medium\" # Classic CPU is enough to submit jobs\n\n  tags = {\n    Type = \"Quantum-Gateway\"\n  }\n}\n</code></pre>"},{"location":"infra/terraform/#analyse-pour-loperationnel","title":"Analyse pour l'Op\u00e9rationnel","text":"<p>Pour un admin Terraform habitu\u00e9, ce code est trivial, et c'est tout l'int\u00e9r\u00eat. L'acc\u00e8s au quantique n'est \"qu'une API de plus\".</p> <ol> <li><code>aws_s3_bucket</code> : C'est votre disque dur partag\u00e9. Le QPU (ex: un ordinateur de chez Rigetti ou IonQ) va uploader ses logs et r\u00e9sultats binaires ici. C'est le point de d\u00e9couplage.</li> <li><code>aws_iam_role</code> : C'est ici que vous contr\u00f4lez les co\u00fbts et la s\u00e9cu. La policy <code>AmazonBraketFullAccess</code> donne le droit d'envoyer des t\u00e2ches aux machines quantiques.</li> <li><code>aws_sagemaker_notebook_instance</code> : Notez le type d'instance <code>ml.t3.medium</code>. C'est du CPU classique standard. Le code Python tourne sur ce CPU, pr\u00e9pare le circuit quantique, et l'envoie au QPU via le r\u00e9seau. On n'a pas besoin de puissance de calcul local, juste d'une connectivit\u00e9 r\u00e9seau vers l'API Braket.</li> </ol> <p>!!! warning \"Cloud Priv\u00e9 et Souverainet\u00e9\"     Dans des contextes haute s\u00e9curit\u00e9 (SecNumCloud, D\u00e9fense, Banque), vous ne pouvez pas installer de QPU dans votre datacenter priv\u00e9.</p> <pre><code>L'architecture de r\u00e9f\u00e9rence consiste alors \u00e0 utiliser un **Proxy/Passerelle** en zone d\u00e9militaris\u00e9e (DMZ). Vos serveurs internes envoient les circuits quantiques \u00e0 ce proxy, qui filtre, anonymise potentiellement les donn\u00e9es, et transmet la requ\u00eate au fournisseur Cloud (AWS/Azure/IBM) via une liaison s\u00e9curis\u00e9e. Le \"backend\" de calcul reste public ou d\u00e9di\u00e9, mais jamais totalement interne.\n</code></pre>"},{"location":"labs/hello_world/","title":"1. Hello World (Ping)","text":""},{"location":"labs/hello_world/#lab-1-hello-world-smoke-test","title":"Lab 1 : \"Hello World\" (Smoke Test)","text":""},{"location":"labs/hello_world/#introduction-le-ping-quantique","title":"Introduction : Le \"Ping\" Quantique","text":"<p>Dans le monde de l'infrastructure, la premi\u00e8re action apr\u00e8s une installation est un <code>ping</code> ou un <code>curl</code> pour v\u00e9rifier la connectivit\u00e9. Dans le monde quantique, l'\u00e9quivalent est de cr\u00e9er un \u00c9tat de Bell.</p> <p>Ce script ne r\u00e9alise pas un calcul utile. Son seul but est de valider la toolchain : 1.  L'interpr\u00e9teur Python est correct. 2.  Le SDK (Qiskit) est charg\u00e9. 3.  Le simulateur local fonctionne.</p> <p>L'objectif est d'intriquer 2 qubits. Si \u00e7a marche, ils doivent toujours donner la m\u00eame valeur lorsqu'on les mesure : soit tous les deux \u00e0 0, soit tous les deux \u00e0 1.</p>"},{"location":"labs/hello_world/#pre-requis","title":"Pr\u00e9-requis","text":"<ul> <li>Python 3.10 ou sup\u00e9rieur.</li> <li>Installation des librairies :     <code>bash     pip install qiskit qiskit-aer</code></li> </ul>"},{"location":"labs/hello_world/#le-code-de-test-quantum_pingpy","title":"Le Code de Test (<code>quantum_ping.py</code>)","text":"<p>Copiez ce code pour tester votre environnement local.</p> <pre><code>#!/usr/bin/env python3\n\"\"\"\nAuthor: Julien Bombled\nLicense: Apache License 2.0\n\nDescription:\nThis script acts as a \"Smoke Test\" for the quantum environment.\nIt creates a simple Bell State (Entanglement) between 2 qubits.\nThis is the quantum equivalent of a \"Hello World\" or \"Ping\".\n\"\"\"\n\nfrom qiskit import QuantumCircuit\nfrom qiskit.primitives import Sampler\nfrom qiskit.visualization import plot_histogram\n\ndef run_quantum_ping():\n    print(\"&gt;&gt;&gt; Starting Quantum Connectivity Test (Smoke Test)...\")\n\n    # 1. Allocation: Request 2 Qubits (like allocating 2 bits of RAM)\n    #    and 2 Classical Bits to store the measurement result.\n    qc = QuantumCircuit(2, 2)\n\n    # 2. Logic: Create Entanglement (The \"Circuit\")\n    #    Apply Hadamard gate (H) on qubit 0 -&gt; Puts it in Superposition (0 and 1 at same time)\n    qc.h(0)\n    #    Apply CNOT gate (CX) between qubit 0 and 1 -&gt; Entangles them.\n    #    If q0 is 0, q1 stays 0. If q0 is 1, q1 flips to 1.\n    qc.cx(0, 1)\n\n    # 3. Measurement: Read the state of qubits into classical bits\n    qc.measure([0, 1], [0, 1])\n\n    print(\"&gt;&gt;&gt; Circuit built successfully.\")\n    print(\"&gt;&gt;&gt; Submitting job to local simulator...\")\n\n    # 4. Execution: Run the circuit on a local simulator\n    #    We run the experiment 1000 times (\"shots\") to get statistics.\n    sampler = Sampler()\n    job = sampler.run(qc)\n    result = job.result()\n\n    # Get the probability distribution (quasi-probabilities)\n    quasi_dists = result.quasi_dists[0]\n\n    # Convert keys from integer to binary string for readability\n    # e.g., 0 -&gt; '00', 3 -&gt; '11'\n    counts = {format(k, '02b'): v for k, v in quasi_dists.items()}\n\n    print(f\"&gt;&gt;&gt; Result (Probabilities): {counts}\")\n\n    return counts\n\nif __name__ == \"__main__\":\n    try:\n        results = run_quantum_ping()\n\n        # Simple validation logic for the SysOp\n        # We expect roughly 50% '00' and 50% '11'.\n        # Small deviations are normal due to probabilistic nature, \n        # but seeing '01' or '10' would indicate a simulator error (noise).\n        if '00' in results and '11' in results:\n            print(\"&gt;&gt;&gt; SUCCESS: Entanglement verified. Environment is healthy.\")\n        else:\n            print(\"&gt;&gt;&gt; FAILURE: Unexpected results. Check installation.\")\n\n    except Exception as e:\n        print(f\"&gt;&gt;&gt; CRITICAL ERROR: {e}\")\n        print(\"&gt;&gt;&gt; Verify that 'qiskit' and 'qiskit-aer' are installed.\")\n</code></pre>"},{"location":"labs/hello_world/#interpretation-pour-le-sysadmin","title":"Interpr\u00e9tation pour le SysAdmin","text":"<p>Une fois le script ex\u00e9cut\u00e9 (<code>python quantum_ping.py</code>), regardez la ligne <code>Result</code>.</p> <ul> <li>R\u00e9sultat attendu : Environ <code>{'00': 0.5, '11': 0.5}</code>.<ul> <li>Cela signifie que les deux qubits sont synchronis\u00e9s (intriqu\u00e9s). Si l'un vaut 0, l'autre vaut 0. Si l'un vaut 1, l'autre vaut 1.</li> </ul> </li> <li>R\u00e9sultat d'erreur : Si vous voyez appara\u00eetre <code>'01'</code> ou <code>'10'</code> avec des probabilit\u00e9s significatives.<ul> <li>Cela signifierait que l'intrication a \u00e9chou\u00e9 (les qubits sont d\u00e9synchronis\u00e9s). Sur un simulateur parfait, c'est impossible. Sur un vrai hardware, ce serait du \"bruit\" (d\u00e9coh\u00e9rence).</li> </ul> </li> </ul>"}]}